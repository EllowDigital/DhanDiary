rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Keep the existing ownership rule at the users level
    match /users/{uid} {
      allow read: if request.auth != null && request.auth.uid == uid;

      // Cash entries subcollection rules (paste/replace this block)
      match /cash_entries/{entryId} {
        // Only the owner can read entries
        allow read: if request.auth != null && request.auth.uid == uid;

        // Allow creates and updates only (disallow hard deletes to enforce soft-delete)
        allow create, update: if request.auth != null
                              && request.auth.uid == uid
                              && validateEntry();

        // NOTE: deletes are intentionally NOT allowed here. Soft-deletes must be performed
        // via an update that sets `isDeleted` / `del = true`.

        // Validation helper: returns true only if all invariants hold
        function validateEntry() {
          // 1) Timestamp: require a numeric ms timestamp either as compressed `u` or `updatedAt`
          let hasU = request.resource.data.keys().hasAny(['u'])
                     && request.resource.data.u is number
                     && request.resource.data.u > 0;
          let hasUpdatedAt = request.resource.data.keys().hasAny(['updatedAt'])
                             && request.resource.data.updatedAt is number
                             && request.resource.data.updatedAt > 0;
          let timeOk = hasU || hasUpdatedAt;

          // 2) If compressed id 'i' is present it MUST equal the document id
          let idOk = !request.resource.data.keys().hasAny(['i']) || (request.resource.data.i == entryId);

          // 3) Limit `note` length to prevent abusive/huge writes (4096 chars)
          //    Use size() to measure string length in rules runtime
          let noteOk = !request.resource.data.keys().hasAny(['note'])
                       || (request.resource.data.note is string && request.resource.data.note.size() <= 4096);

          // 4) Disallow aggregate or server-derived fields from being written into an entry
          let noAgg =
            !request.resource.data.keys().hasAny(['totalInCents']) &&
            !request.resource.data.keys().hasAny(['totalOutCents']) &&
            !request.resource.data.keys().hasAny(['count']) &&
            !request.resource.data.keys().hasAny(['period']) &&
            !request.resource.data.keys().hasAny(['key']);

          // 5) (Optional strict mode) To enforce a limited schema uncomment and adjust:
          // let allowed = ['i','a','c','n','t','cu','d','u','di','del','v','amount','category','note','type','currency','date','updatedAt','deviceId','isDeleted','version'];
          // let onlyAllowed = request.resource.data.keys().hasOnly(allowed);

          return timeOk && idOk && noteOk && noAgg;
        }
      }
    }
  }
}